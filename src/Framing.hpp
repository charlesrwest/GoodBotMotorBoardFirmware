#pragma once

#include<array>

#include "CRC32.hpp"

namespace GoodBot
{

static constexpr char FlagByte = 0x7E;
static constexpr char EscapeByte = 0x7D;
static constexpr char XORByte = 0x20; 
static constexpr char CRCSize = sizeof(crc_t);
static constexpr char MaxEncodedCRCSize = sizeof(crc_t)*2;
static constexpr char MaxEndFrameLength = MaxEncodedCRCSize + sizeof(FlagByte);

uint32_t htonl(uint32_t inputInteger);
uint32_t ntohl(uint32_t inputInteger);

/**
This class maintains an internal state which can be used to create PPP frames byte by byte.

Creating a frame:
Call StartFrame(), which returns the start byte to put at the beginning of the frame
For each character to encode, call EncodeCharacter.  It returns a fixed sized array of message bytes which can contain a variable amount of data.  The number of data bytes for any returned value can be found using the NumberOfEncodedCharactersToUse() function.
When all of the data to be encoded has been given to EncodeCharacter, call EndFrame to get the final flag byte, calculate the CRC and clear the CRC calculation for the next message.

It encodes the data in the following manner:
0: flag byte 0x7E (01111110)
...: Payload bytes followed by CRC (4 byte after decoding) after byte stuffing (any data or CRC flag bytes or 0x7D have 0x7D preappended and then are XORed with 0x20) 
: flag byte 0x7E (01111110)

CRC covers all messages bytes (prior to encoding)
*/
class PPPEncoder
{
public:
/**
This function returns the first byte of the frame and readies the internal CRC calculation.
@return: The first byte of the frame
*/
char StartFrame();

/**
This function updates the internal CRC calculation and returns the (possibly escaped) corresponding frame bytes.
@param byte: The data byte to encode
@return: The encoded bytes (number of bytes returned by calling NumberOfEncodedCharactersToUse())
*/
std::array<char, 2> EncodeCharacter(char byte);

/**
This function returns how many bytes of the last returned frame byte or byte array to use in the message.
@return: How many bytes of a returned value should be used (starting at the front of the array)
*/
int8_t NumberOfEncodedCharactersToUse() const;

/**
This function returns the end flag byte and the escaped 4 byte CRC (can be up to 8 bytes long).
@return: (CRC, end flag byte)
*/
std::array<char, MaxEndFrameLength> EndFrame();

private:
void ResetCRC();
void UpdateCRC(char frameByte);
void FinalizeCRC();

crc_t CRC_VALUE = crc_init();
int8_t ReturnedBytesSize = 0;
};

template<size_t BufferSize>
class PPPDecoder
{
public:

/**
This function takes in a byte which was generated by the PPPEncoder and updates the internal state of the decoder.
@param frameByte: The byte to decode from the frame
@return: true if a valid frame has been completed and data is available.
*/
bool DecodeByte(char frameByte)
{
    if(frameByte != FlagByte)
    {
        Buffer[BufferIndex] = frameByte;
        BufferIndex++;
        BufferIndex = BufferIndex % Buffer.size(); //If the buffer ran out of space, just go back to 0. This frame is going to fail.
        LastByteFrameByte = false;
        return false;
    }


    //It's a flag byte, so see if it's going to work out
    LastByteFrameByte = true;

    //Unescape any escaped bytes
    DecodeFrameData();
    if(!CheckCRC())
    {
        //Invalid frame, so throw out data
        BufferIndex = 0;
        return false;
    }

    //CRC passed, so remove it from the frame buffer and decode the remaining data
    //Remove bytes associated with CRC
    BufferIndex -= CRCSize;

    return true;
}

/**
This function returns a pointer to the internal buffer which can be used to access the data decoded from the frame.  This data is only valid if DecodeByte returned true when it was last called and is of length DecodedDataLength().
@return: A pointer to the internal data buffer
*/
const char* DecodedData()
{
    return Buffer.data();
}

/**
@return: The number of valid data bytes in the buffer returned by DecodedDataLength().
*/
int32_t DecodedDataLength()
{
    if(!LastByteFrameByte)
    {
        return 0;
    }

    return BufferIndex;
}

/**
This function clears the stored decoded data to make space for the next frame.  It should be called after a decoded frame has been read.
*/
void ClearDecodedData()
{
    BufferIndex = 0;
}

private:
void DecodeFrameData()
{
    bool last_byte_escape = false;
    int32_t data_index = 0;
    for(int32_t frame_index = 0; frame_index < BufferIndex; frame_index++)
    {
        if(Buffer[frame_index] == EscapeByte)
        {
            last_byte_escape = true;
            continue;
        }

        //Un-escape any escaped bytes and store
        char byte = last_byte_escape ? Buffer[frame_index] ^ XORByte : Buffer[frame_index];
        Buffer[data_index] = byte;
        data_index++;
        last_byte_escape = false;
    }

    //All frame data decoded, so update buffer size to match decoded data length
    BufferIndex = data_index;

    if(last_byte_escape == true)
    {
        //Can't end with an escape byte, so frame is invalid
        BufferIndex = 0;
    }
}

bool CheckCRC()
{
    if(BufferIndex < CRCSize)
    {
        return false; //Not enough to store a CRC
    }

    //Need to make sure byte order is right, TBD
    crc_t original_CRC = 0;
    int32_t original_CRC_offset = BufferIndex-CRCSize;
    for(int8_t crc_offset = 0; crc_offset < CRCSize; crc_offset++)
    {
        ((char*) &original_CRC)[crc_offset] = Buffer[original_CRC_offset+crc_offset];
    }
    original_CRC = ntohl(original_CRC);

    crc_t crc = crc_init();
    crc = crc_update(crc, Buffer.data(), (BufferIndex-CRCSize));
    crc = crc_finalize(crc);

    return original_CRC == crc;
}

std::array<char, BufferSize> Buffer;
int32_t BufferIndex = 0;
bool LastByteFrameByte = false;
};








}
